{"version":"1","records":[{"hierarchy":{"lvl1":"Cavity polaritons coupled to cavity phonons"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Cavity polaritons coupled to cavity phonons"},"content":"Research repository on the subject of cavity polaritons optomechanically coupled to cavity phonons in linear arrays. We explore the population and energy dynamics of these systems on the contex of the research done in the Optics and Photonics group in the Bariloche Atomic Center. This work has been done under the supervision of Prof. Gonzalo Usaj of the Condensed Matter Theory group.","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Cavity polaritons coupled to cavity phonons","lvl2":"Objectives"},"type":"lvl2","url":"/#objectives","position":2},{"hierarchy":{"lvl1":"Cavity polaritons coupled to cavity phonons","lvl2":"Objectives"},"content":"The main objectives for this work are\n\nExplore the polariton and phonon population dynamics of these arrays under different driving protocols and different intensities\n\nExplore the energy spectrum dynamics of the system in terms of the driving\n\nUnderstand the stability of the different regimes observed under this model.","type":"content","url":"/#objectives","position":3},{"hierarchy":{"lvl1":"Polaritons"},"type":"lvl1","url":"/intro","position":0},{"hierarchy":{"lvl1":"Polaritons"},"content":"The topic of this research project is the study of the population, energy and stability dynamics of cavity polariton arrays optomechanically coupled to cavity phonons. Schematically the process creates a polariton pair by cascading down a ladder of polaritonic states via phonon emission, the initial polaritonic population is generated via coherent or incoherent pumping on a state of high energy. Due to the backaction between the polaritonic and phononic field, the outcome of this whole process is the coherent phonon generation in the cavity thus rendering this system as a phonon cascade laser (PCQL).\n\nThis project has been done under the supervision of Prof. Gonzalo Usaj of the Condensed Matter Theory Department at the Bariloche Atomic Center (C.A.B.). The motivation for this project arises from experimental finding in the Optics and Photonics group at C.A.B., which have found the strong coupling between polaritonic cavity modes via phonons in a wedged cavity.","type":"content","url":"/intro","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/two-site-non-resonant","position":0},{"hierarchy":{"lvl1":""},"content":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt \nimport scienceplots \nplt.style.use(['science', 'no-latex', 'notebook'])\n\n\n\ndata_folder_path = \"/home/ruiz/Documents/polaritons/scripts/cpp/\"\ndata = pd.read_csv(data_folder_path + \"output_time.dat\", delimiter= \"\\t\", header = None).iloc[:, :-1]\n\n\n\ndata.head()\n\n\n\ntime = data[0].to_numpy(dtype = float)\nphi1_r = data[1].to_numpy(dtype = float)\nphi1_i = data[2].to_numpy(dtype = float)\nphi2_r = data[3].to_numpy(dtype = float)\nphi2_i = data[4].to_numpy(dtype = float)\nx = data[5].to_numpy(dtype = float)\nv = data[6].to_numpy(dtype = float)\nn = data[7].to_numpy(dtype = float)\n\n\n\nphi1_mod = phi1_r**2 + phi1_i**2\nphi2_mod = phi2_r**2 + phi2_i**2\n\n\n\nplt.plot(time, phi1_i)\nplt.plot(time, phi1_r)\nplt.plot(time, phi2_i)\nplt.plot(time, phi2_r)\nplt.plot(time, n)\n# plt.xlim(400.0, 410.0)\n# plt.xlim(300, 500)\nplt.xlim(-1.0, 100)\n\n\n\n\n\nf = (phi1_r + 1.0j * phi1_i) * (phi2_r -1.0j * phi2_i)*np.exp(-1.0j * 20.0 * time)\n\n\n\n\ncx_phi1 = phi1_r + 1.0j * phi1_i\ncx_phi2 = phi2_r + 1.0j * phi2_i\n\n\n\n\n# Parameters\ngamma1 = 1.0\ngamma2 = 1.0\nJ = 0.0\ng = 1.0\nxi = 1.0\nOmega = 20.0\n\n# Compute derivatives according to the model\nphi1_drv = -1.0j * (\n    cx_phi1 * (-1.0j * gamma1 + 1.0j * xi * n) +\n    (J + g * x) * np.exp(+1.0j * Omega * time) * cx_phi2\n)\n\nphi2_drv = -1.0j * (\n    cx_phi2 * (-1.0j * gamma2) +\n    (J + g * x) * np.exp(-1.0j * Omega * time) * cx_phi1\n)\n\n\n\n# More accurate derivative for non-uniform timesteps\ndt = np.diff(time)\ndphi1_dt = np.diff(cx_phi1) / dt\n# Add a point to match array sizes\ndphi1_dt = np.append(dphi1_dt, dphi1_dt[-1])\n\n\n\nplt.plot((phi1_drv - dphi1_dt).imag)\n# plt.xlim(0.0, 0.0025e6)\nplt.xscale('log')\n\n\n\nplt.plot(phi1_drv.imag)\nplt.ylim(-1.0, 1.0)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\ndef second_derivative(y, x):\n    \"\"\"\n    Second derivative for non-uniform grids.\n    Preserves array length.\n\n    Parameters\n    ----------\n    y : array_like\n        Function values y(x)\n    x : array_like\n        Grid points (not necessarily uniform)\n\n    Returns\n    -------\n    d2y : np.ndarray\n        Second derivative with same length as y\n    \"\"\"\n    y = np.asarray(y, dtype=float)\n    x = np.asarray(x, dtype=float)\n\n    if len(y) != len(x):\n        raise ValueError(\"x and y must have the same length\")\n    if len(y) < 3:\n        raise ValueError(\"Need at least 3 points\")\n\n    d2y = np.zeros_like(y)\n\n    # Interior points\n    for i in range(1, len(y) - 1):\n        h1 = x[i]   - x[i - 1]\n        h2 = x[i+1] - x[i]\n\n        d2y[i] = 2 * (\n            (y[i+1] - y[i]) / h2 -\n            (y[i]   - y[i-1]) / h1\n        ) / (h1 + h2)\n\n    # Left boundary (forward, non-uniform)\n    h1 = x[1] - x[0]\n    h2 = x[2] - x[1]\n    d2y[0] = 2 * (\n        (y[2] - y[1]) / h2 -\n        (y[1] - y[0]) / h1\n    ) / (h1 + h2)\n\n    # Right boundary (backward, non-uniform)\n    h1 = x[-2] - x[-3]\n    h2 = x[-1] - x[-2]\n    d2y[-1] = 2 * (\n        (y[-1] - y[-2]) / h2 -\n        (y[-2] - y[-3]) / h1\n    ) / (h1 + h2)\n\n    return d2y\n\n\n\n\nddot_x = second_derivative(x, time)\n\n\n\nf = cx_phi1 * np.conj(cx_phi2) * np.exp(-1.0j * 20.0 * time)\n\n\n\nx_ode =ddot_x + 400.0 * x + 0.05* v\n\n\n\nplt.plot(x_ode)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\nplt.plot(-2*20.0*0.05*f.real)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\nplt.plot(dphi1_dt.imag)\nplt.ylim(-1.0, 1.0)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\nplt.plot(phi2_drv.imag)\nplt.ylim(-1.0, 1.0)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\nplt.plot(dphi2_dt.imag)\nplt.ylim(-1.0, 1.0)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\ndphi2_dt = np.diff(cx_phi2) / dt\n# Add a point to match array sizes\ndphi2_dt = np.append(dphi2_dt, dphi2_dt[-1])\n\n\n\nplt.plot((phi2_drv - dphi2_dt).imag)\nplt.xscale('log')\n\n\n\nplt.plot(phi2_drv.imag)\nplt.ylim(-1.5, 1.5)\n\n\n\n\n\nplt.plot(time, f.real)\nplt.xlim(70.0, 100.0)\n\n\n\n\n\nresidue = np.gradient(v, time)-400.0 * x - 0.05 * v\n\n\n\nplt.plot(residue - 2*20*0.05*f.real)\nplt.xlim(0.0, 10rpoy00.0)\n\n\n\n\n\nplt.plot(time, x)\nplt.xlim(0.0, 10.0)\n\n\n\n\n\nplt.plot(time, phi1_mod)\nplt.plot(time, phi2_mod)\nplt.xlim(-0.1, 30)\nplt.ylim(0.0, 10.0)\n# plt.xlim(400, 500\n\n\n\n\n\n\n\n\n\nplt.plot(time, n)\n\n\n\nmask = time > 300\ntime_new = time[mask]\nphi1_i_new = phi1_i[mask]\nphi1_r_new = phi1_r[mask]\n\n\n\ndelta_t = time[1]-time[0]\n\n\n\nfrom scipy.fft import fft, fft2\n\nphi_fft = fft(phi1_r_new +1.0j*phi1_i_new)\n\n\n\nplt.plot(np.roll(np.arange(len(phi_fft))/(len(phi_fft) * delta_t), int(len(phi_fft)/2)), abs(phi_fft)**2/len(phi_fft))\nplt.yscale('log')\n\n\n\nplt.xlim(0.0, 20.0)\nplt.plot(time, phi1_mod)\nplt.plot(time, phi2_mod)\n\n\n\n\nplt.plot(time, n)\nplt.xlim(400.0, 500.0)\n# plt.yscale('log')\n\n\n\n\n\nplt.plot(time, x)\nplt.xlim(300.0, 310.0)\n\n\n\n\n\ndata_folder_path = \"/home/ruiz/Documents/polaritons/data/processed/\"\ndata = pd.read_csv(data_folder_path + \"nonResonantSweepBuilt.dat\", delimiter= \"\\t\", header = None).iloc[:, :-1]\n\n\n\ndata.head()\n\n\n\nplt.scatter(data[0], data[2], label = r'$\\frac{\\langle \\vert \\phi_1\\vert^2 \\rangle}{\\phi_s^2}$')\nplt.scatter(data[0], data[1], label = r'$\\frac{\\langle \\vert \\phi_2\\vert^2 \\rangle}{\\phi_s^2}$')\nplt.scatter(data[0], np.sqrt(data[3]/2))\nplt.scatter(data[0], data[4])\nplt.scatter(data[0], data[5])\nplt.plot(data[0], data[2], label = r'$\\frac{\\langle \\vert \\phi_1\\vert^2 \\rangle}{\\phi_s^2}$')\nplt.plot(data[0], data[1], label = r'$\\frac{\\langle \\vert \\phi_2\\vert^2 \\rangle}{\\phi_s^2}$')\nplt.plot(data[0], np.sqrt(data[3]/2))\nplt.plot(data[0], data[4])\nplt.plot(data[0], data[5])\nplt.grid(True)\nplt.xlabel('Magnitud Normalizada')\nplt.ylabel('Potencia')\nplt.legend()\nplt.ylim(0.0, 3.0)\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/two-site-non-resonant","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/two-site-resonant","position":0},{"hierarchy":{"lvl1":""},"content":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt \nimport scienceplots \nplt.style.use(['science', 'no-latex', 'notebook'])\n\n\n\ndata_folder_path = \"/home/ruiz/Documents/polaritons/data/raw/\"\ndata = pd.read_csv(data_folder_path + \"two_site_resonant.dat\", delimiter= \"\\t\", header = None)\n\n\n\nphi1_r = data[0].to_numpy(dtype = float)\nphi1_i = data[1].to_numpy(dtype = float)\nphi2_r = data[2].to_numpy(dtype = float)\nphi2_i = data[3].to_numpy(dtype = float)\nx = data[4].to_numpy(dtype = float)\nv = data[5].to_numpy(dtype = float)\n\n\n\nphi1_mod = phi1_r**2 + phi1_i**2\nphi2_mod = phi2_r**2 + phi2_i**2\n\n\n\nplt.plot(phi1_i)\nplt.plot(phi1_r)\nplt.plot(phi2_i)\nplt.plot(phi2_r)\nplt.xlim(-1.0, 500)\n\n\n\n\n\n# plt.plot(phi1_mod)\n# plt.plot(phi2_mod)\nplt.plot(x)\nplt.xlim(6000, 10000)\n\n\n\n\n\nx_force = (phi1_r +1.0j* phi1_i) * (phi2_r -1.0j *phi2_i)\nplt.plot(x_force.imag)\nplt.xlim(8000, 8200)\nplt.plot(x)\nplt.yscale('log')\n\n\n\nforce_sweep_data = pd.read_csv(\"/home/ruiz/Documents/polaritons/scripts/cpp/averages.dat\", delimiter = \"\\t\", header = None)\n\n\n\nforce = force_sweep_data[0].to_numpy(dtype = float) \nphi1 = force_sweep_data[1].to_numpy(dtype = float)\nphi2 = force_sweep_data[2].to_numpy(dtype = float)\nx = force_sweep_data[3].to_numpy(dtype = float)\n\n\n\n# plt.plot(force, force**2)\nplt.plot(force ,phi1)\nplt.plot(force ,phi2)\nplt.plot(force, x)\n# plt.plot(force , x/2)\n# plt.plot(force, force - 1 )\n# plt.plot(force, np.ones_like(force))\n\n# plt.xlim(0.0, 2.5)\n# plt.ylim(0.0, 3.0)\n\n","type":"content","url":"/two-site-resonant","position":1},{"hierarchy":{"lvl1":"data"},"type":"lvl1","url":"/readme-1","position":0},{"hierarchy":{"lvl1":"data"},"content":"","type":"content","url":"/readme-1","position":1},{"hierarchy":{"lvl1":"figures"},"type":"lvl1","url":"/readme-2","position":0},{"hierarchy":{"lvl1":"figures"},"content":"","type":"content","url":"/readme-2","position":1},{"hierarchy":{"lvl1":"notebooks"},"type":"lvl1","url":"/readme-3","position":0},{"hierarchy":{"lvl1":"notebooks"},"content":"","type":"content","url":"/readme-3","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/cpp-notebook","position":0},{"hierarchy":{"lvl1":""},"content":"#include<iostream>\n\n\n\n\nint main(){\n    std::cout << \"Hello World\" << std::endl;\n}\n\n","type":"content","url":"/cpp-notebook","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/two-site-non-resonant","position":0},{"hierarchy":{"lvl1":""},"content":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt \nimport scienceplots \nplt.style.use(['science', 'no-latex', 'notebook'])\n\n\n\ndata_folder_path = \"/home/ruiz/Documents/polaritons/scripts/cpp/\"\ndata = pd.read_csv(data_folder_path + \"output_time.dat\", delimiter= \"\\t\", header = None).iloc[:, :-1]\n\n\n\ndata.head()\n\n\n\ntime = data[0].to_numpy(dtype = float)\nphi1_r = data[1].to_numpy(dtype = float)\nphi1_i = data[2].to_numpy(dtype = float)\nphi2_r = data[3].to_numpy(dtype = float)\nphi2_i = data[4].to_numpy(dtype = float)\nx = data[5].to_numpy(dtype = float)\nv = data[6].to_numpy(dtype = float)\nn = data[7].to_numpy(dtype = float)\n\n\n\nphi1_mod = phi1_r**2 + phi1_i**2\nphi2_mod = phi2_r**2 + phi2_i**2\n\n\n\nplt.plot(time, phi1_i)\nplt.plot(time, phi1_r)\nplt.plot(time, phi2_i)\nplt.plot(time, phi2_r)\nplt.plot(time, n)\n# plt.xlim(400.0, 410.0)\n# plt.xlim(300, 500)\nplt.xlim(-1.0, 100)\n\n\n\n\n\nf = (phi1_r + 1.0j * phi1_i) * (phi2_r -1.0j * phi2_i)*np.exp(-1.0j * 20.0 * time)\n\n\n\n\ncx_phi1 = phi1_r + 1.0j * phi1_i\ncx_phi2 = phi2_r + 1.0j * phi2_i\n\n\n\n\n# Parameters\ngamma1 = 1.0\ngamma2 = 1.0\nJ = 0.0\ng = 1.0\nxi = 1.0\nOmega = 20.0\n\n# Compute derivatives according to the model\nphi1_drv = -1.0j * (\n    cx_phi1 * (-1.0j * gamma1 + 1.0j * xi * n) +\n    (J + g * x) * np.exp(+1.0j * Omega * time) * cx_phi2\n)\n\nphi2_drv = -1.0j * (\n    cx_phi2 * (-1.0j * gamma2) +\n    (J + g * x) * np.exp(-1.0j * Omega * time) * cx_phi1\n)\n\n\n\n# More accurate derivative for non-uniform timesteps\ndt = np.diff(time)\ndphi1_dt = np.diff(cx_phi1) / dt\n# Add a point to match array sizes\ndphi1_dt = np.append(dphi1_dt, dphi1_dt[-1])\n\n\n\nplt.plot((phi1_drv - dphi1_dt).imag)\n# plt.xlim(0.0, 0.0025e6)\nplt.xscale('log')\n\n\n\nplt.plot(phi1_drv.imag)\nplt.ylim(-1.0, 1.0)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\ndef second_derivative(y, x):\n    \"\"\"\n    Second derivative for non-uniform grids.\n    Preserves array length.\n\n    Parameters\n    ----------\n    y : array_like\n        Function values y(x)\n    x : array_like\n        Grid points (not necessarily uniform)\n\n    Returns\n    -------\n    d2y : np.ndarray\n        Second derivative with same length as y\n    \"\"\"\n    y = np.asarray(y, dtype=float)\n    x = np.asarray(x, dtype=float)\n\n    if len(y) != len(x):\n        raise ValueError(\"x and y must have the same length\")\n    if len(y) < 3:\n        raise ValueError(\"Need at least 3 points\")\n\n    d2y = np.zeros_like(y)\n\n    # Interior points\n    for i in range(1, len(y) - 1):\n        h1 = x[i]   - x[i - 1]\n        h2 = x[i+1] - x[i]\n\n        d2y[i] = 2 * (\n            (y[i+1] - y[i]) / h2 -\n            (y[i]   - y[i-1]) / h1\n        ) / (h1 + h2)\n\n    # Left boundary (forward, non-uniform)\n    h1 = x[1] - x[0]\n    h2 = x[2] - x[1]\n    d2y[0] = 2 * (\n        (y[2] - y[1]) / h2 -\n        (y[1] - y[0]) / h1\n    ) / (h1 + h2)\n\n    # Right boundary (backward, non-uniform)\n    h1 = x[-2] - x[-3]\n    h2 = x[-1] - x[-2]\n    d2y[-1] = 2 * (\n        (y[-1] - y[-2]) / h2 -\n        (y[-2] - y[-3]) / h1\n    ) / (h1 + h2)\n\n    return d2y\n\n\n\n\nddot_x = second_derivative(x, time)\n\n\n\nf = cx_phi1 * np.conj(cx_phi2) * np.exp(-1.0j * 20.0 * time)\n\n\n\nx_ode =ddot_x + 400.0 * x + 0.05* v\n\n\n\nplt.plot(x_ode)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\nplt.plot(-2*20.0*0.05*f.real)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\nplt.plot(dphi1_dt.imag)\nplt.ylim(-1.0, 1.0)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\nplt.plot(phi2_drv.imag)\nplt.ylim(-1.0, 1.0)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\nplt.plot(dphi2_dt.imag)\nplt.ylim(-1.0, 1.0)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\ndphi2_dt = np.diff(cx_phi2) / dt\n# Add a point to match array sizes\ndphi2_dt = np.append(dphi2_dt, dphi2_dt[-1])\n\n\n\nplt.plot((phi2_drv - dphi2_dt).imag)\nplt.xscale('log')\n\n\n\nplt.plot(phi2_drv.imag)\nplt.ylim(-1.5, 1.5)\n\n\n\n\n\nplt.plot(time, f.real)\nplt.xlim(70.0, 100.0)\n\n\n\n\n\nresidue = np.gradient(v, time)-400.0 * x - 0.05 * v\n\n\n\nplt.plot(residue - 2*20*0.05*f.real)\nplt.xlim(0.0, 10rpoy00.0)\n\n\n\n\n\nplt.plot(time, x)\nplt.xlim(0.0, 10.0)\n\n\n\n\n\nplt.plot(time, phi1_mod)\nplt.plot(time, phi2_mod)\nplt.xlim(-0.1, 30)\nplt.ylim(0.0, 10.0)\n# plt.xlim(400, 500\n\n\n\n\n\n\n\n\n\nplt.plot(time, n)\n\n\n\nmask = time > 300\ntime_new = time[mask]\nphi1_i_new = phi1_i[mask]\nphi1_r_new = phi1_r[mask]\n\n\n\ndelta_t = time[1]-time[0]\n\n\n\nfrom scipy.fft import fft, fft2\n\nphi_fft = fft(phi1_r_new +1.0j*phi1_i_new)\n\n\n\nplt.plot(np.roll(np.arange(len(phi_fft))/(len(phi_fft) * delta_t), int(len(phi_fft)/2)), abs(phi_fft)**2/len(phi_fft))\nplt.yscale('log')\n\n\n\nplt.xlim(0.0, 20.0)\nplt.plot(time, phi1_mod)\nplt.plot(time, phi2_mod)\n\n\n\n\nplt.plot(time, n)\nplt.xlim(400.0, 500.0)\n# plt.yscale('log')\n\n\n\n\n\nplt.plot(time, x)\nplt.xlim(300.0, 310.0)\n\n\n\n\n\ndata_folder_path = \"/home/ruiz/Documents/polaritons/data/processed/\"\ndata = pd.read_csv(data_folder_path + \"nonResonantSweepBuilt.dat\", delimiter= \"\\t\", header = None).iloc[:, :-1]\n\n\n\ndata.head()\n\n\n\nplt.scatter(data[0], data[2], label = r'$\\frac{\\langle \\vert \\phi_1\\vert^2 \\rangle}{\\phi_s^2}$')\nplt.scatter(data[0], data[1], label = r'$\\frac{\\langle \\vert \\phi_2\\vert^2 \\rangle}{\\phi_s^2}$')\nplt.scatter(data[0], np.sqrt(data[3]/2))\nplt.scatter(data[0], data[4])\nplt.scatter(data[0], data[5])\nplt.plot(data[0], data[2], label = r'$\\frac{\\langle \\vert \\phi_1\\vert^2 \\rangle}{\\phi_s^2}$')\nplt.plot(data[0], data[1], label = r'$\\frac{\\langle \\vert \\phi_2\\vert^2 \\rangle}{\\phi_s^2}$')\nplt.plot(data[0], np.sqrt(data[3]/2))\nplt.plot(data[0], data[4])\nplt.plot(data[0], data[5])\nplt.grid(True)\nplt.xlabel('Magnitud Normalizada')\nplt.ylabel('Potencia')\nplt.legend()\nplt.ylim(0.0, 3.0)\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/two-site-non-resonant","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/two-site-resonant","position":0},{"hierarchy":{"lvl1":""},"content":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt \nimport scienceplots \nplt.style.use(['science', 'no-latex', 'notebook'])\n\n\n\ndata_folder_path = \"/home/ruiz/Documents/polaritons/data/raw/\"\ndata = pd.read_csv(data_folder_path + \"two_site_resonant.dat\", delimiter= \"\\t\", header = None)\n\n\n\nphi1_r = data[0].to_numpy(dtype = float)\nphi1_i = data[1].to_numpy(dtype = float)\nphi2_r = data[2].to_numpy(dtype = float)\nphi2_i = data[3].to_numpy(dtype = float)\nx = data[4].to_numpy(dtype = float)\nv = data[5].to_numpy(dtype = float)\n\n\n\nphi1_mod = phi1_r**2 + phi1_i**2\nphi2_mod = phi2_r**2 + phi2_i**2\n\n\n\nplt.plot(phi1_i)\nplt.plot(phi1_r)\nplt.plot(phi2_i)\nplt.plot(phi2_r)\nplt.xlim(-1.0, 500)\n\n\n\n\n\n# plt.plot(phi1_mod)\n# plt.plot(phi2_mod)\nplt.plot(x)\nplt.xlim(6000, 10000)\n\n\n\n\n\nx_force = (phi1_r +1.0j* phi1_i) * (phi2_r -1.0j *phi2_i)\nplt.plot(x_force.imag)\nplt.xlim(8000, 8200)\nplt.plot(x)\nplt.yscale('log')\n\n\n\nforce_sweep_data = pd.read_csv(\"/home/ruiz/Documents/polaritons/scripts/cpp/averages.dat\", delimiter = \"\\t\", header = None)\n\n\n\nforce = force_sweep_data[0].to_numpy(dtype = float) \nphi1 = force_sweep_data[1].to_numpy(dtype = float)\nphi2 = force_sweep_data[2].to_numpy(dtype = float)\nx = force_sweep_data[3].to_numpy(dtype = float)\n\n\n\n# plt.plot(force, force**2)\nplt.plot(force ,phi1)\nplt.plot(force ,phi2)\nplt.plot(force, x)\n# plt.plot(force , x/2)\n# plt.plot(force, force - 1 )\n# plt.plot(force, np.ones_like(force))\n\n# plt.xlim(0.0, 2.5)\n# plt.ylim(0.0, 3.0)\n\n","type":"content","url":"/two-site-resonant","position":1},{"hierarchy":{"lvl1":"notes"},"type":"lvl1","url":"/readme-4","position":0},{"hierarchy":{"lvl1":"notes"},"content":"","type":"content","url":"/readme-4","position":1},{"hierarchy":{"lvl1":"Research Article"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Research Article"},"content":" \\email{arturo.ruiz@ib.edu.ar}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Abstract%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nSome abstract\n\n","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Research Article","lvl2":"Agradecimientos"},"type":"lvl2","url":"/#agradecimientos","position":2},{"hierarchy":{"lvl1":"Research Article","lvl2":"Agradecimientos"},"content":" Recursos computacionales fueron proveidos por el cluster HPC del Departamento de Física del Centro Atómico Bariloche. Computational resources were provided by the HPC cluster of the Physics Department at Centro Atómico Bariloche (CNEA). \\bibliographystyle{apsrev4-2} \\bibliography{references}","type":"content","url":"/#agradecimientos","position":3},{"hierarchy":{"lvl1":"reports"},"type":"lvl1","url":"/readme-5","position":0},{"hierarchy":{"lvl1":"reports"},"content":"","type":"content","url":"/readme-5","position":1},{"hierarchy":{"lvl1":"Weekly report (12/22 - 12/28)"},"type":"lvl1","url":"/report-12-22-12-28","position":0},{"hierarchy":{"lvl1":"Weekly report (12/22 - 12/28)"},"content":"Progress this week has been done by creating the polariton.h and cavity_config.h C++ headers. These headers provide a high level interface for the numerical modeling of driven-dissipative polaritonic lattices. In contrast to previous numerical implementations, generation of arbitrary lattice topologies is done easily with an object oriented approach. With this approach ODEs are not explicitly written in the program but are generated through the creation of PolaritonMode and PhononMode objects which are then coupled to each other. Some features are to be implemented later like live parameter modification and plotting and also Fourier and Lyapunov analysis. However, as it is today, the headers constitute a full working tool to be used on this research.\n\nWe hope that the creation of these functions can render further research to be more straightforward.","type":"content","url":"/report-12-22-12-28","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/test","position":0},{"hierarchy":{"lvl1":""},"content":"# ==================================================\n# Two-site polariton system with phonon\n# Random initial conditions\n# Zero reservoir power (set in C++)\n# ==================================================\n\n[global]\ntime = 0.0\nrandom_seed = auto    # or fixed integer for reproducibility\n\n\n# ==================================================\n# Polariton modes\n# ==================================================\n\n[polariton site_1]\nU = 0.0\ngamma = 1.0\n\ninitial_real = uniform(-1.0, 1.0)\ninitial_imag = uniform(-1.0, 1.0)\n\n\n[polariton site_2]\nU = 0.0\ngamma = 1.0\n\ninitial_real = uniform(-1.0, 1.0)\ninitial_imag = uniform(-1.0, 1.0)\n\n\n# ==================================================\n# Reservoirs (ZERO power here)\n# ==================================================\n\n[reservoir site_2_res]\ntarget = site_2\ncoupling = 1.0\ntau = 600\npower = 0.0\nalpha = 3.25\nn0 = uniform(0.1, 0.6)\n\n\n# ==================================================\n# Phonon mode\n# ==================================================\n\n[phonon phonon_1]\nomega = 20.0\ngamma = 0.05\n\ninitial_position = uniform(-10.0, 10.0)\ninitial_velocity = uniform(-200.0, 200.0)\n\n\n# ==================================================\n# Polariton–polariton coupling via phonon\n# ==================================================\n\n[coupling site_1_to_site_2]\nfrom = site_1\nto = site_2\nphonon = phonon_1\nJ = 0.0\ng = 1.0\ndelta = 0.0\nabove = true\n\n\n[coupling site_2_to_site_1]\nfrom = site_2\nto = site_1\nphonon = phonon_1\nJ = 0.0\ng = 1.0\ndelta = 0.0\nabove = false\n\n\n# ==================================================\n# Phonon pairing\n# ==================================================\n\n[pairing phonon_pair]\nphonon = phonon_1\nsites = site_1, site_2\ndelta = 0.0\ng = 1.0\n","type":"content","url":"/test","position":1}]}