{"version":"1","records":[{"hierarchy":{"lvl1":"Cavity Polaritons Research Documentation"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Cavity Polaritons Research Documentation"},"content":"Research repository on the subject of cavity polaritons optomechanically coupled via cavity phonons in linear arrays. We explore the population and energy dynamics of these systems in the context of research done in the Optics and Photonics group at the Bariloche Atomic Center. This research is based on the theoretical modeling of polariton arrays using a tight-binding and semiclassical approximation of the Gross-Pitaevski equation.","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Cavity Polaritons Research Documentation","lvl2":"Objectives"},"type":"lvl2","url":"/#objectives","position":2},{"hierarchy":{"lvl1":"Cavity Polaritons Research Documentation","lvl2":"Objectives"},"content":"For this research we intend to achieve the following set of goals:\n\nModel the population, stability and energy dynamics obtained from previous measurements done in the Optics and Photonics group\n\nWrite software that facilitates the analysis of potentially more complex polariton arrangements, couplings and driving schemes to be used by other people\n\nEngineer arrangements and driving protocols with potential of generating interesting emerging phenomena from these systems\n\nMore relevant results born from this research will eventually be uploaded to Arxiv and (hopefully) be presented as a journal article. For more information about the model refer to \n\nthis page and to \n\nthe associated page.","type":"content","url":"/#objectives","position":3},{"hierarchy":{"lvl1":"data"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"data"},"content":"","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"figures"},"type":"lvl1","url":"/readme-1","position":0},{"hierarchy":{"lvl1":"figures"},"content":"","type":"content","url":"/readme-1","position":1},{"hierarchy":{"lvl1":"Introduction"},"type":"lvl1","url":"/intro","position":0},{"hierarchy":{"lvl1":"Introduction"},"content":"The topics of this research project are the population, energy and stability dynamics of cavity polariton arrays optomechanically coupled via cavity phonons. Schematically the process creates exciton-polaritons by cascading down a ladder of polaritonic states via phonon emission. The initial polaritonic population is generated via coherent or incoherent pumping on a state of high energy. Due to the backaction between the polaritonic and phononic field, the outcome of this whole process is the coherent phonon generation in the cavity thus rendering this system as a phonon cascade laser (PCQL).","type":"content","url":"/intro","position":1},{"hierarchy":{"lvl1":"Introduction","lvl2":"Cavity polaritons and cavity phonons"},"type":"lvl2","url":"/intro#cavity-polaritons-and-cavity-phonons","position":2},{"hierarchy":{"lvl1":"Introduction","lvl2":"Cavity polaritons and cavity phonons"},"content":"Cavity polaritons are mixed quasi particles born from the combination of a photon and some crystal excitation. In our case we’ll concern us with Wannier-Mott excitons which are a hydrogen-like bound states originated from the Coulomb interaction between a conduction band electron and a valence band hole. Due to a very strong collective dipole interaction between these excitons and the microcavity photon fields, a strong light-matter coupling is achieved and anticrossing in both component’s disperssions is observed at their degeneracy points see \n\nFigure 1. This originates two bands called the lower and upper polariton branches (\n\nDeng2010). Their mixed nature conferes a very interesting set of properties to these quasiparticles like high temperature Bose-Einstein condensation, superfluidity and other qualities that belong to the realm of the quantum fluids of light (\n\nCarusotto2012).\n\n\n\nFigure 1:Schematic of the anticrossing and the formation of polariton branches. The reservoir’s and condensate’s relaxation dynamics are shown and both driving schemes are contrasted.\n\nRealizations of polaritonic systems require the confinement of both their light and excitonic components. The former condition can be obtained by the use of a distributed Bragg reflector (DBR) which creates a reflection profile that bounces some frequency range (stopband) and lets in a sharply defined middle frequency, see \n\nFigure 2.\n\n\n\nFigure 2:Reflection spectrum for the light and sound inside the heterostructure. A stopband with a middle dip is provided by the Bragg reflector.\n\nIn some structures, this DBR generates an analog profile for the lattice vibrations (phonons) thus also confining these in the process (\n\nTrigo2002). Confinement in one of the excitonic component’s dimensions is provided by the use of quantum wells (QWs) by the alternation of semiconductors with different bandgaps (for example GaAS and AlGaAs). By etching the heterostructure in other geometrical patterns it’s possible to generate confinement in directions perpendicular to the growth axis, see \n\nFigure 3.\n\n\n\nFigure 3:Semiconductor heterostructure that serves as a cavity as it confines both light and phononic modes. Exciton confinement is provided by the introduction of quantum wells.\n\nIn this way localized polaritonic modes along the heterostructure are generated and, by careful parameter engineering, it’s possible to tune their respective energies and couplings. For example, by tuning the trap’s size, it’s possible to create a cascade-like structure like the one depicted in \n\nFigure 4.\n\n\n\nFigure 4:Energy schematic of the polariton modes present at a heterostructure with square geometry.\n\nAppart from providing some polariton relaxation mechanisms, phonons can interact with the polariton field producing a set of phenomena like optomechanically induced tunneling, self sustained mechanical oscillations above some threshold and frequency locking (\n\nReynoso2022, \n\nChafatinos2023) which are of interest for the present research. In particular, we’ll be concerned with a system where many spatially extended modes are confined in a single trap which induces a linear coupling on the phonon’s coordinate. To enhance the phonon dependent coupling, the trap is tuned to make each of the polariton modes be separated in energy in an ammount similar to the phonon’s frequency (\n\nPapuccio2025).","type":"content","url":"/intro#cavity-polaritons-and-cavity-phonons","position":3},{"hierarchy":{"lvl1":"Introduction","lvl2":"Model preliminaries"},"type":"lvl2","url":"/intro#model-preliminaries","position":4},{"hierarchy":{"lvl1":"Introduction","lvl2":"Model preliminaries"},"content":"Modeling of non-equilibrium Bose-Einstein condensates of this sort is done using a generalized Gross-Pitaevskii equation (\n\nWouters2007):i \\frac{\\partial \\psi}{\\partial t} = \\left\\{ -\\frac{\\hbar \\nabla^2}{2m_{LP}} + \\frac{i}{2}[R(n_R) - \\gamma] + U \\vert \\psi \\vert^2\\right\\}\\psi + F(\\vec r, t),\n\nwhose main feautures that separate it from a traditional Schrödinger equation is the introduction of dissipative, self interaction (Hartree), and driving terms. For the latter the condensate can be subject to incoherent (non resonant) driving by means of an exciton reservoir whose population relaxes by many mechanisms through the lower polariton branch. This process is described phenomenologically by an independent equation for the reservoir population:\\frac{\\partial n_R}{\\partial t} = P - \\gamma_R n_R - R(n_R)\\vert \\psi(\\vec r) \\vert^2 + D \\nabla^2 n_R\n\nwhere P is the rate of increase in the reservoir population given by the driving. In general relaxation times in reservoirs are much shorter than that of exciton-polaritons, and thus an adiabatic approximation is valid (\\partial_t n_R = 0). Alternatively coherent driving at the condensate’s resonant frequency can be supplied by F(\\vec r, t) \\propto e^{i\\omega_d t}. Condensate-reservoir coupling is introuduced by the function R(n_R), for the purposes of this research we’ll consider a linear coupling given by R(n_R) = R\\times n_R where R measures the strength of such coupling.","type":"content","url":"/intro#model-preliminaries","position":5},{"hierarchy":{"lvl1":"Introduction","lvl2":"Details of the model"},"type":"lvl2","url":"/intro#details-of-the-model","position":6},{"hierarchy":{"lvl1":"Introduction","lvl2":"Details of the model"},"content":"In absence of driving and dissipation, our model may be first described as a Bose-Hubbard model with phonon state dependent hoppings:\\hat{\\mathcal H} = \\sum_{i}\\hbar \\omega_i \\hat a^\\dag_i \\hat a_i + \\frac{1}{2}\\sum_i \\hbar U_i \\hat a_i^\\dag \\hat a_i (\\hat a^\\dag_i \\hat a_i -1) + \\sum_k \\hbar \\Omega_k \\hat b^\\dag_k \\hat b_k + \\sum_{\\langle i,j \\rangle}\\hbar \\hat J_{ij} (\\hat a^\\dag_i \\hat a_j + \\hat a^\\dag_j \\hat a_i),\n\nwith \\hat b_k^\\dag (\\hat b_k) creation (destruction) operator of a phonon with frequency \\Omega_k, \\langle i, j \\rangle denotes summation over coupled modes and \\hat J_{ij} = J^0_{ij} + g_{ij} (\\hat b^\\dag_{k(ij)} + \\hat b_{k(ij)}) where k(ij) denotes the phonon which couples modes i and j. Generally, there may be phonons which couple multiple polariton mode pairs so that k(ij) = k(i'j'). This tight-binding approximation might be derived from two possible scenarios:\n\nThe polariton modes are localized in a discrete lattice and the \\hat a_i^\\dag (\\hat a_i) creation (destruction) operators act upon localized modes in that lattice like the ones in \n\nFigure 4.\n\nThe polariton modes may not be localized in a lattice (see \n\nFigure 5) and the equation is derived by projecting the associated Schrödinger equation (in absence of phonons) to the (lowest) eigenmodes of energies \\hbar \\omega_i. Orthogonality of the eigenmodes in this case gives J^0_{ij} = 0.\n\n\n\nFigure 5:Energy schematic of non-localized polariton modes generated from a wedge cavity analog to the system presented at (\n\nPapuccio2025). Polariton mode energies are engineered to have differences similar to the confined phonons’ frequency so that coupling between modes is mediated through them.\n\nAs we’ll concern ourselves with solutions with large number of quanta, the semiclassical approximation is applyable. This consists of replacing all bosonic operators by complex functions\\hat a_i \\rightarrow a_i,\\quad \\hat a_i^\\dag \\rightarrow a_i^*, \\quad \\hat b_k \\rightarrow b_k, \\quad \\hat b_k^\\dag \\rightarrow b_k^*\n\nafter that we may derive an equation of motion for the phonon’s generalized position operator \\hat x_k = \\hat b_k + \\hat b_k^\\dag using the Heisenberg’s picture (HP) and then applying the semiclassical approximation. Additionaly we may introduce some linear loss term on the phonon velocity operator with loss rate \\Gamma_k. Finally we introduce driving and dissipation terms in each mode’s HP equation of motion corresponding to the ones appearing in the \n\nGPE. Thus the model equations are:i\\dot a_i = \\left\\{\\omega_i + \\frac{i}{2}(R_i n_i - \\gamma_i) + U_i \\vert a_i \\vert^2\\right\\} a_i + F_i e^{-i\\omega_{d}^i t}+\\sum_{\\langle i, j \\rangle} \\left(J^0_{ij} + g_{ij} x_{k(ij)}\\right)a_j\\ddot x_k = -\\Omega_k^2 x_k - \\Gamma_k \\dot x_k - \\sum_{(i, j) \\in G_k} 2\\Omega_k g_{ij}(a_i a_j^* + a_i^* a_j)\n\nwhere G_k is the set of pairs of polariton modes which are coupled by phonon k. We’ll concern ourselves with the experimentally relevant case where the phonon has a sharply defined frequency, polariton mode’s widths are small compared to their energy separations and the latter are comparable to the phonon energy so that stimulated phonon emission and absorption is enhanced:\\Gamma_k \\ll \\gamma_i \\ll \\Omega_k,\\quad \\forall i, k\\Omega_k \\sim \\vert \\omega_i - \\omega_j\\vert,\\quad \\forall (i,j) \\in G_k.\n\nIn this regime, the polariton modes will develop their dynamics in Fourier components near or centered their natural frequencies and thus it will prove to be more convenient to express these equations in the rotating frame of the polariton modes by defining the substitution a_i = \\varphi_i e^{-i\\omega_i t} and thus the equations become:i\\dot \\varphi_i = \\left\\{\\frac{i}{2}(R_i n_i - \\gamma_i) + U_i \\vert \\varphi_i \\vert^2 \\right\\} + F_i e^{-i(\\omega_d^i - \\omega_i)t} + \\sum_{\\langle i, j \\rangle}\\left(J_{ij}^0 + g_{ij} x_{k(ij)}\\right)e^{-i(\\omega_j - \\omega_i)t} \\varphi_j\\ddot x_k = -\\Omega_k^2 x_k - \\Gamma_k \\dot x_k - 4\\Omega_k\\sum_{(i, j) \\in G_k}  g_{ij}\\operatorname{Re}\\left(\\varphi_i \\varphi_j^*e^{-i(\\omega_i -\\omega_j)t}\\right)","type":"content","url":"/intro#details-of-the-model","position":7},{"hierarchy":{"lvl1":"notebooks"},"type":"lvl1","url":"/readme-2","position":0},{"hierarchy":{"lvl1":"notebooks"},"content":"","type":"content","url":"/readme-2","position":1},{"hierarchy":{"lvl1":"Testing Markdown"},"type":"lvl1","url":"/new-notebook","position":0},{"hierarchy":{"lvl1":"Testing Markdown"},"content":"import numpy as np\nimport matplotlib.pyplot as plt\n\n\n\n","type":"content","url":"/new-notebook","position":1},{"hierarchy":{"lvl1":"Testing Markdown"},"type":"lvl1","url":"/new-notebook#testing-markdown","position":2},{"hierarchy":{"lvl1":"Testing Markdown"},"content":"This is something that works or not?\n\n#\n\n","type":"content","url":"/new-notebook#testing-markdown","position":3},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/cpp-notebook","position":0},{"hierarchy":{"lvl1":""},"content":"#include<iostream>\n\n\n\n\nint main(){\n    std::cout << \"Hello World\" << std::endl;\n}\n\n","type":"content","url":"/cpp-notebook","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/two-site-non-resonant","position":0},{"hierarchy":{"lvl1":""},"content":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt \nimport scienceplots \nplt.style.use(['science', 'no-latex', 'notebook'])\n\n\n\ndata_folder_path = \"/home/ruiz/Documents/polaritons/scripts/cpp/\"\ndata = pd.read_csv(data_folder_path + \"output_time.dat\", delimiter= \"\\t\", header = None).iloc[:, :-1]\n\n\n\ndata.head()\n\n\n\ntime = data[0].to_numpy(dtype = float)\nphi1_r = data[1].to_numpy(dtype = float)\nphi1_i = data[2].to_numpy(dtype = float)\nphi2_r = data[3].to_numpy(dtype = float)\nphi2_i = data[4].to_numpy(dtype = float)\nx = data[5].to_numpy(dtype = float)\nv = data[6].to_numpy(dtype = float)\nn = data[7].to_numpy(dtype = float)\n\n\n\nphi1_mod = phi1_r**2 + phi1_i**2\nphi2_mod = phi2_r**2 + phi2_i**2\n\n\n\nplt.plot(time, phi1_i)\nplt.plot(time, phi1_r)\nplt.plot(time, phi2_i)\nplt.plot(time, phi2_r)\nplt.plot(time, n)\n# plt.xlim(400.0, 410.0)\n# plt.xlim(300, 500)\nplt.xlim(-1.0, 100)\n\n\n\n\n\nf = (phi1_r + 1.0j * phi1_i) * (phi2_r -1.0j * phi2_i)*np.exp(-1.0j * 20.0 * time)\n\n\n\n\ncx_phi1 = phi1_r + 1.0j * phi1_i\ncx_phi2 = phi2_r + 1.0j * phi2_i\n\n\n\n\n# Parameters\ngamma1 = 1.0\ngamma2 = 1.0\nJ = 0.0\ng = 1.0\nxi = 1.0\nOmega = 20.0\n\n# Compute derivatives according to the model\nphi1_drv = -1.0j * (\n    cx_phi1 * (-1.0j * gamma1 + 1.0j * xi * n) +\n    (J + g * x) * np.exp(+1.0j * Omega * time) * cx_phi2\n)\n\nphi2_drv = -1.0j * (\n    cx_phi2 * (-1.0j * gamma2) +\n    (J + g * x) * np.exp(-1.0j * Omega * time) * cx_phi1\n)\n\n\n\n# More accurate derivative for non-uniform timesteps\ndt = np.diff(time)\ndphi1_dt = np.diff(cx_phi1) / dt\n# Add a point to match array sizes\ndphi1_dt = np.append(dphi1_dt, dphi1_dt[-1])\n\n\n\nplt.plot((phi1_drv - dphi1_dt).imag)\n# plt.xlim(0.0, 0.0025e6)\nplt.xscale('log')\n\n\n\nplt.plot(phi1_drv.imag)\nplt.ylim(-1.0, 1.0)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\ndef second_derivative(y, x):\n    \"\"\"\n    Second derivative for non-uniform grids.\n    Preserves array length.\n\n    Parameters\n    ----------\n    y : array_like\n        Function values y(x)\n    x : array_like\n        Grid points (not necessarily uniform)\n\n    Returns\n    -------\n    d2y : np.ndarray\n        Second derivative with same length as y\n    \"\"\"\n    y = np.asarray(y, dtype=float)\n    x = np.asarray(x, dtype=float)\n\n    if len(y) != len(x):\n        raise ValueError(\"x and y must have the same length\")\n    if len(y) < 3:\n        raise ValueError(\"Need at least 3 points\")\n\n    d2y = np.zeros_like(y)\n\n    # Interior points\n    for i in range(1, len(y) - 1):\n        h1 = x[i]   - x[i - 1]\n        h2 = x[i+1] - x[i]\n\n        d2y[i] = 2 * (\n            (y[i+1] - y[i]) / h2 -\n            (y[i]   - y[i-1]) / h1\n        ) / (h1 + h2)\n\n    # Left boundary (forward, non-uniform)\n    h1 = x[1] - x[0]\n    h2 = x[2] - x[1]\n    d2y[0] = 2 * (\n        (y[2] - y[1]) / h2 -\n        (y[1] - y[0]) / h1\n    ) / (h1 + h2)\n\n    # Right boundary (backward, non-uniform)\n    h1 = x[-2] - x[-3]\n    h2 = x[-1] - x[-2]\n    d2y[-1] = 2 * (\n        (y[-1] - y[-2]) / h2 -\n        (y[-2] - y[-3]) / h1\n    ) / (h1 + h2)\n\n    return d2y\n\n\n\n\nddot_x = second_derivative(x, time)\n\n\n\nf = cx_phi1 * np.conj(cx_phi2) * np.exp(-1.0j * 20.0 * time)\n\n\n\nx_ode =ddot_x + 400.0 * x + 0.05* v\n\n\n\nplt.plot(x_ode)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\nplt.plot(-2*20.0*0.05*f.real)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\nplt.plot(dphi1_dt.imag)\nplt.ylim(-1.0, 1.0)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\nplt.plot(phi2_drv.imag)\nplt.ylim(-1.0, 1.0)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\nplt.plot(dphi2_dt.imag)\nplt.ylim(-1.0, 1.0)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\ndphi2_dt = np.diff(cx_phi2) / dt\n# Add a point to match array sizes\ndphi2_dt = np.append(dphi2_dt, dphi2_dt[-1])\n\n\n\nplt.plot((phi2_drv - dphi2_dt).imag)\nplt.xscale('log')\n\n\n\nplt.plot(phi2_drv.imag)\nplt.ylim(-1.5, 1.5)\n\n\n\n\n\nplt.plot(time, f.real)\nplt.xlim(70.0, 100.0)\n\n\n\n\n\nresidue = np.gradient(v, time)-400.0 * x - 0.05 * v\n\n\n\nplt.plot(residue - 2*20*0.05*f.real)\nplt.xlim(0.0, 10rpoy00.0)\n\n\n\n\n\nplt.plot(time, x)\nplt.xlim(0.0, 10.0)\n\n\n\n\n\nplt.plot(time, phi1_mod)\nplt.plot(time, phi2_mod)\nplt.xlim(-0.1, 30)\nplt.ylim(0.0, 10.0)\n# plt.xlim(400, 500\n\n\n\n\n\n\n\n\n\nplt.plot(time, n)\n\n\n\nmask = time > 300\ntime_new = time[mask]\nphi1_i_new = phi1_i[mask]\nphi1_r_new = phi1_r[mask]\n\n\n\ndelta_t = time[1]-time[0]\n\n\n\nfrom scipy.fft import fft, fft2\n\nphi_fft = fft(phi1_r_new +1.0j*phi1_i_new)\n\n\n\nplt.plot(np.roll(np.arange(len(phi_fft))/(len(phi_fft) * delta_t), int(len(phi_fft)/2)), abs(phi_fft)**2/len(phi_fft))\nplt.yscale('log')\n\n\n\nplt.xlim(0.0, 20.0)\nplt.plot(time, phi1_mod)\nplt.plot(time, phi2_mod)\n\n\n\n\nplt.plot(time, n)\nplt.xlim(400.0, 500.0)\n# plt.yscale('log')\n\n\n\n\n\nplt.plot(time, x)\nplt.xlim(300.0, 310.0)\n\n\n\n\n\ndata_folder_path = \"/home/ruiz/Documents/polaritons/data/processed/\"\ndata = pd.read_csv(data_folder_path + \"nonResonantSweepBuilt.dat\", delimiter= \"\\t\", header = None).iloc[:, :-1]\n\n\n\ndata.head()\n\n\n\nplt.scatter(data[0], data[2], label = r'$\\frac{\\langle \\vert \\phi_1\\vert^2 \\rangle}{\\phi_s^2}$')\nplt.scatter(data[0], data[1], label = r'$\\frac{\\langle \\vert \\phi_2\\vert^2 \\rangle}{\\phi_s^2}$')\nplt.scatter(data[0], np.sqrt(data[3]/2))\nplt.scatter(data[0], data[4])\nplt.scatter(data[0], data[5])\nplt.plot(data[0], data[2], label = r'$\\frac{\\langle \\vert \\phi_1\\vert^2 \\rangle}{\\phi_s^2}$')\nplt.plot(data[0], data[1], label = r'$\\frac{\\langle \\vert \\phi_2\\vert^2 \\rangle}{\\phi_s^2}$')\nplt.plot(data[0], np.sqrt(data[3]/2))\nplt.plot(data[0], data[4])\nplt.plot(data[0], data[5])\nplt.grid(True)\nplt.xlabel('Magnitud Normalizada')\nplt.ylabel('Potencia')\nplt.legend()\nplt.ylim(0.0, 3.0)\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/two-site-non-resonant","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/two-site-resonant","position":0},{"hierarchy":{"lvl1":""},"content":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt \nimport scienceplots \nplt.style.use(['science', 'no-latex', 'notebook'])\n\n\n\ndata_folder_path = \"/home/ruiz/Documents/polaritons/data/raw/\"\ndata = pd.read_csv(data_folder_path + \"two_site_resonant.dat\", delimiter= \"\\t\", header = None)\n\n\n\nphi1_r = data[0].to_numpy(dtype = float)\nphi1_i = data[1].to_numpy(dtype = float)\nphi2_r = data[2].to_numpy(dtype = float)\nphi2_i = data[3].to_numpy(dtype = float)\nx = data[4].to_numpy(dtype = float)\nv = data[5].to_numpy(dtype = float)\n\n\n\nphi1_mod = phi1_r**2 + phi1_i**2\nphi2_mod = phi2_r**2 + phi2_i**2\n\n\n\nplt.plot(phi1_i)\nplt.plot(phi1_r)\nplt.plot(phi2_i)\nplt.plot(phi2_r)\nplt.xlim(-1.0, 500)\n\n\n\n\n\n# plt.plot(phi1_mod)\n# plt.plot(phi2_mod)\nplt.plot(x)\nplt.xlim(6000, 10000)\n\n\n\n\n\nx_force = (phi1_r +1.0j* phi1_i) * (phi2_r -1.0j *phi2_i)\nplt.plot(x_force.imag)\nplt.xlim(8000, 8200)\nplt.plot(x)\nplt.yscale('log')\n\n\n\nforce_sweep_data = pd.read_csv(\"/home/ruiz/Documents/polaritons/scripts/cpp/averages.dat\", delimiter = \"\\t\", header = None)\n\n\n\nforce = force_sweep_data[0].to_numpy(dtype = float) \nphi1 = force_sweep_data[1].to_numpy(dtype = float)\nphi2 = force_sweep_data[2].to_numpy(dtype = float)\nx = force_sweep_data[3].to_numpy(dtype = float)\n\n\n\n# plt.plot(force, force**2)\nplt.plot(force ,phi1)\nplt.plot(force ,phi2)\nplt.plot(force, x)\n# plt.plot(force , x/2)\n# plt.plot(force, force - 1 )\n# plt.plot(force, np.ones_like(force))\n\n# plt.xlim(0.0, 2.5)\n# plt.ylim(0.0, 3.0)\n\n","type":"content","url":"/two-site-resonant","position":1},{"hierarchy":{"lvl1":"notes"},"type":"lvl1","url":"/readme-3","position":0},{"hierarchy":{"lvl1":"notes"},"content":"","type":"content","url":"/readme-3","position":1},{"hierarchy":{"lvl1":"reports"},"type":"lvl1","url":"/readme-4","position":0},{"hierarchy":{"lvl1":"reports"},"content":"","type":"content","url":"/readme-4","position":1},{"hierarchy":{"lvl1":"Weekly report (12/22 - 12/28)"},"type":"lvl1","url":"/report-12-22-12-28","position":0},{"hierarchy":{"lvl1":"Weekly report (12/22 - 12/28)"},"content":"Progress this week has been done by creating the polariton.h and cavity_config.h C++ headers. These headers provide a high level interface for the numerical modeling of driven-dissipative polaritonic lattices. In contrast to previous numerical implementations, generation of arbitrary lattice topologies is done easily with an object oriented approach. With this approach ODEs are not explicitly written in the program but are generated through the creation of PolaritonMode and PhononMode objects which are then coupled to each other. Some features are to be implemented later like live parameter modification and plotting and also Fourier and Lyapunov analysis. However, as it is today, the headers constitute a full working tool to be used on this research.\n\nWe hope that the creation of these functions can render further research to be more straightforward.","type":"content","url":"/report-12-22-12-28","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/test","position":0},{"hierarchy":{"lvl1":""},"content":"# ==================================================\n# Two-site polariton system with phonon\n# Random initial conditions\n# Zero reservoir power (set in C++)\n# ==================================================\n\n[global]\ntime = 0.0\nrandom_seed = auto    # or fixed integer for reproducibility\n\n\n# ==================================================\n# Polariton modes\n# ==================================================\n\n[polariton site_1]\nU = 0.0\ngamma = 1.0\n\ninitial_real = uniform(-1.0, 1.0)\ninitial_imag = uniform(-1.0, 1.0)\n\n\n[polariton site_2]\nU = 0.0\ngamma = 1.0\n\ninitial_real = uniform(-1.0, 1.0)\ninitial_imag = uniform(-1.0, 1.0)\n\n\n# ==================================================\n# Reservoirs (ZERO power here)\n# ==================================================\n\n[reservoir site_2_res]\ntarget = site_2\ncoupling = 1.0\ntau = 600\npower = 0.0\nalpha = 3.25\nn0 = uniform(0.1, 0.6)\n\n\n# ==================================================\n# Phonon mode\n# ==================================================\n\n[phonon phonon_1]\nomega = 20.0\ngamma = 0.05\n\ninitial_position = uniform(-10.0, 10.0)\ninitial_velocity = uniform(-200.0, 200.0)\n\n\n# ==================================================\n# Polariton–polariton coupling via phonon\n# ==================================================\n\n[coupling site_1_to_site_2]\nfrom = site_1\nto = site_2\nphonon = phonon_1\nJ = 0.0\ng = 1.0\ndelta = 0.0\nabove = true\n\n\n[coupling site_2_to_site_1]\nfrom = site_2\nto = site_1\nphonon = phonon_1\nJ = 0.0\ng = 1.0\ndelta = 0.0\nabove = false\n\n\n# ==================================================\n# Phonon pairing\n# ==================================================\n\n[pairing phonon_pair]\nphonon = phonon_1\nsites = site_1, site_2\ndelta = 0.0\ng = 1.0\n","type":"content","url":"/test","position":1}]}