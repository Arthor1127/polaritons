{"version":"1","records":[{"hierarchy":{"lvl1":"Cavity Polaritons Research Documentation"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Cavity Polaritons Research Documentation"},"content":"Research repository on the subject of cavity polaritons optomechanically coupled via cavity phonons in linear arrays. We explore the population and energy dynamics of these systems in the context of research done in the Optics and Photonics group at the Bariloche Atomic Center. This research is based on the theoretical modeling of polariton arrays using a tight-binding and semiclassical approximation of the Gross-Pitaevski equation. This work has been done under the supervision of Prof. Gonzalo Usaj of the Condensed Matter Theory group.","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Cavity Polaritons Research Documentation","lvl2":"Objectives"},"type":"lvl2","url":"/#objectives","position":2},{"hierarchy":{"lvl1":"Cavity Polaritons Research Documentation","lvl2":"Objectives"},"content":"For this research we intend to achieve the following set of goals:\n\nModel the population, stability and energy dynamics obtained from previous measurements done in the Optics and Photonics group\n\nWrite software that facilitates the analysis of potentially more complex polariton arrangements, couplings and driving schemes to be used by other people\n\nEngineer arrangements and driving protocols with potential of generating interesting emerging phenomena from these systems\n\nExplore different parameter regimes and from these identify the most relevant set of the former\n\nMore relevant results born from this research will eventually be uploaded to Arxiv and (hopefully) be presented as a journal article. For more information about the model refer to \n\nthis page and to \n\nthe associated page.","type":"content","url":"/#objectives","position":3},{"hierarchy":{"lvl1":"data"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"data"},"content":"","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"figures"},"type":"lvl1","url":"/readme-1","position":0},{"hierarchy":{"lvl1":"figures"},"content":"","type":"content","url":"/readme-1","position":1},{"hierarchy":{"lvl1":"Details of the model"},"type":"lvl1","url":"/intro","position":0},{"hierarchy":{"lvl1":"Details of the model"},"content":"\n\n\n\n\n\n\n\nFigure 1: (a) Semiconductor heterostructure that serves as a cavity as it confines both light and phononic modes. Exciton confinement is provided by the introduction of quantum wells. (b) Schematic of the polariton branches. The reservoir's and condensate's relaxation dynamics are shown and both driving schemes are contrasted. (c) Reflection spectrum for the light and sound inside the heterostructure. A stopband with a middle dip is provided by the Bragg reflector. (d) Energy schematic of the polariton modes present at a heterostructure with square geometry.","type":"content","url":"/intro","position":1},{"hierarchy":{"lvl1":"Details of the model"},"type":"lvl1","url":"/intro#details-of-the-model","position":2},{"hierarchy":{"lvl1":"Details of the model"},"content":"The topic of this research project is the study of the population, energy and stability dynamics of cavity polariton arrays optomechanically coupled via cavity phonons. Schematically the process creates exciton-polaritons by cascading down a ladder of polaritonic states via phonon emission. The initial polaritonic population is generated via coherent or incoherent pumping on a state of high energy. Due to the backaction between the polaritonic and phononic field, the outcome of this whole process is the coherent phonon generation in the cavity thus rendering this system as a phonon cascade laser (PCQL).\n\nModeling of non-equilibrium Bose-Einstein condensates \n\n(Wouters2007) of this sort is done using a generalized Gross-Pitaevskii equation:i \\frac{\\partial \\psi}{\\partial t} = \\left\\{ -\\frac{\\hbar \\nabla^2}{2m_{LP}} + \\frac{i}{2}[R(n_R) - \\gamma] + U \\vert \\psi \\vert^2\\right\\}\\psi + F(\\vec r, t),\n\nwhose main feautures that separate it from a traditional Schrödinger equation is the introduction of dissipative, self interaction (Hartree), and driving terms. For the latter the condensate can be subject to incoherent (non resonant) driving by means of an exciton reservoir whose population relaxes by many mechanisms through the lower polariton branch. This process is described phenomenologically by an independent equation for the reservoir population:\\frac{\\partial n_R}{\\partial t} = P - \\gamma_R n_R - R(n_R)\\vert \\psi(\\vec r) \\vert^2 + D \\nabla^2 n_R\n\nwhere P is the rate of increase in the reservoir population given by the driving. In general relaxation times in reservoirs are much shorter than that of exciton-polaritons, and thus an adiabatic approximation is valid (\\partial_t n_R = 0). Alternatively coherent driving at the condensate’s resonant frequency can be supplied by F(\\vec r, t) \\propto e^{i\\omega_d t}. Condensate-reservoir coupling is introuduced by the function R(n_R), for the purposes of this research we’ll consider a linear coupling given by R(n_R) = R\\times n_R where R measures the strength of such coupling.","type":"content","url":"/intro#details-of-the-model","position":3},{"hierarchy":{"lvl1":"notebooks"},"type":"lvl1","url":"/readme-2","position":0},{"hierarchy":{"lvl1":"notebooks"},"content":"","type":"content","url":"/readme-2","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/cpp-notebook","position":0},{"hierarchy":{"lvl1":""},"content":"#include<iostream>\n\n\n\n\nint main(){\n    std::cout << \"Hello World\" << std::endl;\n}\n\n","type":"content","url":"/cpp-notebook","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/two-site-non-resonant","position":0},{"hierarchy":{"lvl1":""},"content":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt \nimport scienceplots \nplt.style.use(['science', 'no-latex', 'notebook'])\n\n\n\ndata_folder_path = \"/home/ruiz/Documents/polaritons/scripts/cpp/\"\ndata = pd.read_csv(data_folder_path + \"output_time.dat\", delimiter= \"\\t\", header = None).iloc[:, :-1]\n\n\n\ndata.head()\n\n\n\ntime = data[0].to_numpy(dtype = float)\nphi1_r = data[1].to_numpy(dtype = float)\nphi1_i = data[2].to_numpy(dtype = float)\nphi2_r = data[3].to_numpy(dtype = float)\nphi2_i = data[4].to_numpy(dtype = float)\nx = data[5].to_numpy(dtype = float)\nv = data[6].to_numpy(dtype = float)\nn = data[7].to_numpy(dtype = float)\n\n\n\nphi1_mod = phi1_r**2 + phi1_i**2\nphi2_mod = phi2_r**2 + phi2_i**2\n\n\n\nplt.plot(time, phi1_i)\nplt.plot(time, phi1_r)\nplt.plot(time, phi2_i)\nplt.plot(time, phi2_r)\nplt.plot(time, n)\n# plt.xlim(400.0, 410.0)\n# plt.xlim(300, 500)\nplt.xlim(-1.0, 100)\n\n\n\n\n\nf = (phi1_r + 1.0j * phi1_i) * (phi2_r -1.0j * phi2_i)*np.exp(-1.0j * 20.0 * time)\n\n\n\n\ncx_phi1 = phi1_r + 1.0j * phi1_i\ncx_phi2 = phi2_r + 1.0j * phi2_i\n\n\n\n\n# Parameters\ngamma1 = 1.0\ngamma2 = 1.0\nJ = 0.0\ng = 1.0\nxi = 1.0\nOmega = 20.0\n\n# Compute derivatives according to the model\nphi1_drv = -1.0j * (\n    cx_phi1 * (-1.0j * gamma1 + 1.0j * xi * n) +\n    (J + g * x) * np.exp(+1.0j * Omega * time) * cx_phi2\n)\n\nphi2_drv = -1.0j * (\n    cx_phi2 * (-1.0j * gamma2) +\n    (J + g * x) * np.exp(-1.0j * Omega * time) * cx_phi1\n)\n\n\n\n# More accurate derivative for non-uniform timesteps\ndt = np.diff(time)\ndphi1_dt = np.diff(cx_phi1) / dt\n# Add a point to match array sizes\ndphi1_dt = np.append(dphi1_dt, dphi1_dt[-1])\n\n\n\nplt.plot((phi1_drv - dphi1_dt).imag)\n# plt.xlim(0.0, 0.0025e6)\nplt.xscale('log')\n\n\n\nplt.plot(phi1_drv.imag)\nplt.ylim(-1.0, 1.0)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\ndef second_derivative(y, x):\n    \"\"\"\n    Second derivative for non-uniform grids.\n    Preserves array length.\n\n    Parameters\n    ----------\n    y : array_like\n        Function values y(x)\n    x : array_like\n        Grid points (not necessarily uniform)\n\n    Returns\n    -------\n    d2y : np.ndarray\n        Second derivative with same length as y\n    \"\"\"\n    y = np.asarray(y, dtype=float)\n    x = np.asarray(x, dtype=float)\n\n    if len(y) != len(x):\n        raise ValueError(\"x and y must have the same length\")\n    if len(y) < 3:\n        raise ValueError(\"Need at least 3 points\")\n\n    d2y = np.zeros_like(y)\n\n    # Interior points\n    for i in range(1, len(y) - 1):\n        h1 = x[i]   - x[i - 1]\n        h2 = x[i+1] - x[i]\n\n        d2y[i] = 2 * (\n            (y[i+1] - y[i]) / h2 -\n            (y[i]   - y[i-1]) / h1\n        ) / (h1 + h2)\n\n    # Left boundary (forward, non-uniform)\n    h1 = x[1] - x[0]\n    h2 = x[2] - x[1]\n    d2y[0] = 2 * (\n        (y[2] - y[1]) / h2 -\n        (y[1] - y[0]) / h1\n    ) / (h1 + h2)\n\n    # Right boundary (backward, non-uniform)\n    h1 = x[-2] - x[-3]\n    h2 = x[-1] - x[-2]\n    d2y[-1] = 2 * (\n        (y[-1] - y[-2]) / h2 -\n        (y[-2] - y[-3]) / h1\n    ) / (h1 + h2)\n\n    return d2y\n\n\n\n\nddot_x = second_derivative(x, time)\n\n\n\nf = cx_phi1 * np.conj(cx_phi2) * np.exp(-1.0j * 20.0 * time)\n\n\n\nx_ode =ddot_x + 400.0 * x + 0.05* v\n\n\n\nplt.plot(x_ode)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\nplt.plot(-2*20.0*0.05*f.real)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\nplt.plot(dphi1_dt.imag)\nplt.ylim(-1.0, 1.0)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\nplt.plot(phi2_drv.imag)\nplt.ylim(-1.0, 1.0)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\nplt.plot(dphi2_dt.imag)\nplt.ylim(-1.0, 1.0)\nplt.xlim(0.0, 0.1e6)\n\n\n\n\n\ndphi2_dt = np.diff(cx_phi2) / dt\n# Add a point to match array sizes\ndphi2_dt = np.append(dphi2_dt, dphi2_dt[-1])\n\n\n\nplt.plot((phi2_drv - dphi2_dt).imag)\nplt.xscale('log')\n\n\n\nplt.plot(phi2_drv.imag)\nplt.ylim(-1.5, 1.5)\n\n\n\n\n\nplt.plot(time, f.real)\nplt.xlim(70.0, 100.0)\n\n\n\n\n\nresidue = np.gradient(v, time)-400.0 * x - 0.05 * v\n\n\n\nplt.plot(residue - 2*20*0.05*f.real)\nplt.xlim(0.0, 10rpoy00.0)\n\n\n\n\n\nplt.plot(time, x)\nplt.xlim(0.0, 10.0)\n\n\n\n\n\nplt.plot(time, phi1_mod)\nplt.plot(time, phi2_mod)\nplt.xlim(-0.1, 30)\nplt.ylim(0.0, 10.0)\n# plt.xlim(400, 500\n\n\n\n\n\n\n\n\n\nplt.plot(time, n)\n\n\n\nmask = time > 300\ntime_new = time[mask]\nphi1_i_new = phi1_i[mask]\nphi1_r_new = phi1_r[mask]\n\n\n\ndelta_t = time[1]-time[0]\n\n\n\nfrom scipy.fft import fft, fft2\n\nphi_fft = fft(phi1_r_new +1.0j*phi1_i_new)\n\n\n\nplt.plot(np.roll(np.arange(len(phi_fft))/(len(phi_fft) * delta_t), int(len(phi_fft)/2)), abs(phi_fft)**2/len(phi_fft))\nplt.yscale('log')\n\n\n\nplt.xlim(0.0, 20.0)\nplt.plot(time, phi1_mod)\nplt.plot(time, phi2_mod)\n\n\n\n\nplt.plot(time, n)\nplt.xlim(400.0, 500.0)\n# plt.yscale('log')\n\n\n\n\n\nplt.plot(time, x)\nplt.xlim(300.0, 310.0)\n\n\n\n\n\ndata_folder_path = \"/home/ruiz/Documents/polaritons/data/processed/\"\ndata = pd.read_csv(data_folder_path + \"nonResonantSweepBuilt.dat\", delimiter= \"\\t\", header = None).iloc[:, :-1]\n\n\n\ndata.head()\n\n\n\nplt.scatter(data[0], data[2], label = r'$\\frac{\\langle \\vert \\phi_1\\vert^2 \\rangle}{\\phi_s^2}$')\nplt.scatter(data[0], data[1], label = r'$\\frac{\\langle \\vert \\phi_2\\vert^2 \\rangle}{\\phi_s^2}$')\nplt.scatter(data[0], np.sqrt(data[3]/2))\nplt.scatter(data[0], data[4])\nplt.scatter(data[0], data[5])\nplt.plot(data[0], data[2], label = r'$\\frac{\\langle \\vert \\phi_1\\vert^2 \\rangle}{\\phi_s^2}$')\nplt.plot(data[0], data[1], label = r'$\\frac{\\langle \\vert \\phi_2\\vert^2 \\rangle}{\\phi_s^2}$')\nplt.plot(data[0], np.sqrt(data[3]/2))\nplt.plot(data[0], data[4])\nplt.plot(data[0], data[5])\nplt.grid(True)\nplt.xlabel('Magnitud Normalizada')\nplt.ylabel('Potencia')\nplt.legend()\nplt.ylim(0.0, 3.0)\n\n\n\n\n\n\n\n\n\n","type":"content","url":"/two-site-non-resonant","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/two-site-resonant","position":0},{"hierarchy":{"lvl1":""},"content":"import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt \nimport scienceplots \nplt.style.use(['science', 'no-latex', 'notebook'])\n\n\n\ndata_folder_path = \"/home/ruiz/Documents/polaritons/data/raw/\"\ndata = pd.read_csv(data_folder_path + \"two_site_resonant.dat\", delimiter= \"\\t\", header = None)\n\n\n\nphi1_r = data[0].to_numpy(dtype = float)\nphi1_i = data[1].to_numpy(dtype = float)\nphi2_r = data[2].to_numpy(dtype = float)\nphi2_i = data[3].to_numpy(dtype = float)\nx = data[4].to_numpy(dtype = float)\nv = data[5].to_numpy(dtype = float)\n\n\n\nphi1_mod = phi1_r**2 + phi1_i**2\nphi2_mod = phi2_r**2 + phi2_i**2\n\n\n\nplt.plot(phi1_i)\nplt.plot(phi1_r)\nplt.plot(phi2_i)\nplt.plot(phi2_r)\nplt.xlim(-1.0, 500)\n\n\n\n\n\n# plt.plot(phi1_mod)\n# plt.plot(phi2_mod)\nplt.plot(x)\nplt.xlim(6000, 10000)\n\n\n\n\n\nx_force = (phi1_r +1.0j* phi1_i) * (phi2_r -1.0j *phi2_i)\nplt.plot(x_force.imag)\nplt.xlim(8000, 8200)\nplt.plot(x)\nplt.yscale('log')\n\n\n\nforce_sweep_data = pd.read_csv(\"/home/ruiz/Documents/polaritons/scripts/cpp/averages.dat\", delimiter = \"\\t\", header = None)\n\n\n\nforce = force_sweep_data[0].to_numpy(dtype = float) \nphi1 = force_sweep_data[1].to_numpy(dtype = float)\nphi2 = force_sweep_data[2].to_numpy(dtype = float)\nx = force_sweep_data[3].to_numpy(dtype = float)\n\n\n\n# plt.plot(force, force**2)\nplt.plot(force ,phi1)\nplt.plot(force ,phi2)\nplt.plot(force, x)\n# plt.plot(force , x/2)\n# plt.plot(force, force - 1 )\n# plt.plot(force, np.ones_like(force))\n\n# plt.xlim(0.0, 2.5)\n# plt.ylim(0.0, 3.0)\n\n","type":"content","url":"/two-site-resonant","position":1},{"hierarchy":{"lvl1":"notes"},"type":"lvl1","url":"/readme-3","position":0},{"hierarchy":{"lvl1":"notes"},"content":"","type":"content","url":"/readme-3","position":1},{"hierarchy":{"lvl1":"reports"},"type":"lvl1","url":"/readme-4","position":0},{"hierarchy":{"lvl1":"reports"},"content":"","type":"content","url":"/readme-4","position":1},{"hierarchy":{"lvl1":"Weekly report (12/22 - 12/28)"},"type":"lvl1","url":"/report-12-22-12-28","position":0},{"hierarchy":{"lvl1":"Weekly report (12/22 - 12/28)"},"content":"Progress this week has been done by creating the polariton.h and cavity_config.h C++ headers. These headers provide a high level interface for the numerical modeling of driven-dissipative polaritonic lattices. In contrast to previous numerical implementations, generation of arbitrary lattice topologies is done easily with an object oriented approach. With this approach ODEs are not explicitly written in the program but are generated through the creation of PolaritonMode and PhononMode objects which are then coupled to each other. Some features are to be implemented later like live parameter modification and plotting and also Fourier and Lyapunov analysis. However, as it is today, the headers constitute a full working tool to be used on this research.\n\nWe hope that the creation of these functions can render further research to be more straightforward.","type":"content","url":"/report-12-22-12-28","position":1},{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/test","position":0},{"hierarchy":{"lvl1":""},"content":"# ==================================================\n# Two-site polariton system with phonon\n# Random initial conditions\n# Zero reservoir power (set in C++)\n# ==================================================\n\n[global]\ntime = 0.0\nrandom_seed = auto    # or fixed integer for reproducibility\n\n\n# ==================================================\n# Polariton modes\n# ==================================================\n\n[polariton site_1]\nU = 0.0\ngamma = 1.0\n\ninitial_real = uniform(-1.0, 1.0)\ninitial_imag = uniform(-1.0, 1.0)\n\n\n[polariton site_2]\nU = 0.0\ngamma = 1.0\n\ninitial_real = uniform(-1.0, 1.0)\ninitial_imag = uniform(-1.0, 1.0)\n\n\n# ==================================================\n# Reservoirs (ZERO power here)\n# ==================================================\n\n[reservoir site_2_res]\ntarget = site_2\ncoupling = 1.0\ntau = 600\npower = 0.0\nalpha = 3.25\nn0 = uniform(0.1, 0.6)\n\n\n# ==================================================\n# Phonon mode\n# ==================================================\n\n[phonon phonon_1]\nomega = 20.0\ngamma = 0.05\n\ninitial_position = uniform(-10.0, 10.0)\ninitial_velocity = uniform(-200.0, 200.0)\n\n\n# ==================================================\n# Polariton–polariton coupling via phonon\n# ==================================================\n\n[coupling site_1_to_site_2]\nfrom = site_1\nto = site_2\nphonon = phonon_1\nJ = 0.0\ng = 1.0\ndelta = 0.0\nabove = true\n\n\n[coupling site_2_to_site_1]\nfrom = site_2\nto = site_1\nphonon = phonon_1\nJ = 0.0\ng = 1.0\ndelta = 0.0\nabove = false\n\n\n# ==================================================\n# Phonon pairing\n# ==================================================\n\n[pairing phonon_pair]\nphonon = phonon_1\nsites = site_1, site_2\ndelta = 0.0\ng = 1.0\n","type":"content","url":"/test","position":1}]}